网络通信

参考文章

[一文搞懂TCP与UPD的区别](https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html)

[图解网络](https://www.xiaolincoding.com/network/)

[关于TCP三次握手和四次挥手，满分回答在此](https://segmentfault.com/a/1190000039165592)

[SSL/TLS协议详解](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/)

# 1 开放式互联网模型

开放式互联网模型（OpenSystermInterconnection Model），简称OSI模型，是一种互联网概念化模型，由国际标准化组织（InternationalOrganization forStandardization），简称ISO，提出。OSI模型将互联网分为七层分别为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

![OSI模型与tcp/ip模型](C:\Users\wangjie\Desktop\study\OkHttp3\img\OSI_tcp_ip模型.png)

# 1 TCP/IP网络模型

计算机与网络设备要相互通信，双方就必须基于相同的协议。比如，如何探测通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要实现确定。不同的硬件、操作系统之间的通信都需要一种规则，这种规则称为协议。TCP/IP网络模型是一系列网络协议的总称。这些协议可以分为四层，分别为链路层、网络层、传输层、应用层。

## 1.1 应用层

最上层的，电脑手机使用的应用软件都是在应用层实现。当两个设备的应用需要通信的时候，应用把数据传给传输层。应用层不用关心数据是如何传输的。应用层对应操作系统的用户态，传输层及以下对应操作系统的内核态。

## 1.2 传输层

应用层的数据会传给传输层，传输层为应用层提供网络支持。

在传输层有两个重要的通信协议，分别是TCP和UDP。

### 1.2.1 UDP

UDP传输层协议全称是用户数据报协议(User Datagram Protocol)。它有以下特点：

#### 1.2.1.1 面向无连接

首先在发送数据前不需要建立连接。

#### 1.2.1.2 有单播、多播、广播的功能

UDP不止支持一对一的传输方式，同样支持一对多、多对多、多对一的方式，也就是说UDP提供了单播、多播、广播的功能。

#### 1.2.1.3 UDP是面向报文的

不会对数据报文进行拆分和拼接操作。具体来说：

. 在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了。

. 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作。

因此应用层必须选择合适大小的报文。

#### 1.2.1.4 不可靠性

由于发送数据前不建立连接，这种情况就是不可靠的。传输层收到什么数据就传递什么数据，不备份数据，不关心对方是否接收到数据。以恒定的速度发送数据，即使网络环境不好，也不会调整发送速度，会导致丢包。

#### 1.2.1.5 头部开销小，传输数据报文高效

UDP头部只有8个字节，开销小，相比TCP的至少二十字节少得多，传输数据报文高效。

### 1.2.2 TCP

TCP协议全称是传输控制协议(Transmission Control Protocol)。是一种面向连接、基于字节流、可靠的传输层协议。

#### 1.2.2.1 面向连接

一定时一对一的，不能向UDP协议可以一对多，多对多的通信。

#### 1.2.2.2 基于字节流

数据通过TCP协议传输时，数据可能被操作系统拆分成多个TCP段。TCP报文段是有序的，当前一个报文段没有收到的时候，即使收到了后面的报文段，也不能传给应用层处理，同时重复的TCP报文段会自动丢弃。

#### 1.2.2.3 可靠的

无论网络链路中发生了怎样的便能话，TCP都可以保证一个报文段能够到达接受方。

应用需要传输的数据可能非常大，如果直接传递就不好控制，当传递的数据包大小超过MSS（最大数据报文段长度），就要将数据包分块。这个每个分块叫做TCP段(Segment)。

当设备作为接收方时，传输层将数据包传递给应用层，但是一台设备上可能有很多应用在接收或传递数据，因此需要将应用区分开来，端口可以区分应用。由于传输层的数据包中的TCP头会携带端口，因此接收方可以识别出该数据包发送给哪个应用。

## 1.3 网络层

网络层常用的时IP协议（Internet Protocol）。传输层将数据传递给网络层，IP协议会在报文的基础上加上IP头组成IP报文，如果IP报文大小超过MTU（Maximum Transmission Unit，以太网中一般为1500字节），协议就会将报文再次分块。每个分块叫packet。

![应用层_传输层_网络层等报文结构](C:\Users\wangjie\Desktop\study\OkHttp3\img\应用层_传输层_网络层等报文结构.webp)

用IP地址给设备编号，对于IPv4协议，IPi地址共有32位，分成了四段（192.168.100.1），每段是8位。IP地址有两重意义：

. 网络号，即设备属于哪个子网；

. 主机号，即设备属于哪个子网下的主机。

IP地址结合子网掩码可以计算出网络号和主机号。IP地址和子网掩码进行位与运算得到网络号，IP地址和取反后的子网掩码进行位与运算得到主机号。根据IP地址和子网掩码计算得到网络号和主机号的过程叫做寻址。

实际场景中两台设备之间有很多网关、路由器、交换机等众多网络设备，形成很多条网络路径，当报文到达某个网络节点后，接着由路由算法决定走哪一条网络路径。

IP协议由寻址和路由两个作用，寻址就是获取目标设备所在的网络号和主机号，路由就是获取报文到达目标设备的网络路径。

## 1.4 链路层

网络层将IP报文传递给链路层，链路层会在报文的基础上添加MAC头，并封装成数据帧（Data Frame）发送到网络。

## 1.5 总结

链路层传输的是帧(Frame)、网络层传输的是包(packet)、传输层传输的是段(Segment)。

# 2 TCP

## 2.1 TCP头

TCP头部有多个字段，这些字段咱用的大小不同。

![TCP头](C:\Users\wangjie\Desktop\study\OkHttp3\img\tcp头.webp)

源端口号和目标端口号是不可少的，用来标识接收和发送方的应用。

序号：在建立连接时发送方主机生成的一个随机数作为其初始值，发送SYN包给接收方主机，每发送一次数据，就累加一次该数据字节数的大小。用来解决数据包乱序问题。

确认号：期望收到对方下一个数据包的序列号，若确认号为N，则序号N-1之前的数据都收到了。用来解决丢包问题。

控制位有6个，比较重要，每个控制位各占一个字节。

紧急位URG：当URG=1时，表明该报文段中有紧急数据，是高优先级的，应尽快发送，不用在缓存中排队。该控制位需要配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）。

确认ACK：仅当ACK=1时，确认号字段才有效，当ACK=0时确认号无效。TCP规定，在连接建立后所有传送的报文段的ACK位必须为1。

推送PSH：当两个应用通信时，有时一端的应用希望在键入一个命令后立即就能得到对方的响应。在这种情况下，TCP就可以使用推送（PUSH）操作。这时，发送方TCP把PSH设置为1，并发送一个报文段。接收方TCP收到PSH=1的报文段，就尽快响应，不用等到整个缓存都填满后再响应。

复位RST：当RST=1时，表明TCP连接中出现了严重错误（比如主机崩溃或其他原因），必须断开连接，然后再重新建立连接。

同步SYN：SYN=1表明希望建立连接。

终止FIN：当FIN=1时，表明不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方可以相互交换FIN位为1的TCP段。

## 2.2 TCP连接建立

### 2.2.1 TCP三次握手过程

TCP是面向连接的协议，使用TCP前需要建立连接，而建立连接时通过三次握手实现的。每一次握手都需要发送TCP报文段，并设置自身状态，对方在接受报文段之后也响应设置各自的状态或发送相关TCP报文段。

![TCP三次握手](C:\Users\wangjie\Desktop\study\OkHttp3\img\TCP三次握手.webp)

(1) 一开始，客户端和服务端都处于CLOSE状态。先是服务端主动监听某个端口，处于LISTEN状态。

![三次握手第一个报文](C:\Users\wangjie\Desktop\study\OkHttp3\img\三次握手第一个报文.webp)

(2) 客户端随机初始化序号(client_isn)，将序号置于TCP头的序号字段中，同时将同步SYN状态位置为1，表示SYN报文段。接着把第一个SYN报文段发送给服务端，表示向服务端发起连接，该报文段不包含应用层数据，之后客户端处于SYN_SENT状态。

![三次握手第二个报文](C:\Users\wangjie\Desktop\study\OkHttp3\img\三次握手第二个报文.webp)

(3) 服务端收到客户端的SYN报文段后，首先随机初始化序号，并将该序号置于自己TCP头部的序号字段中，将确认号设置为client_isn + 1，接着将同步SYN位和确认ACK位都设置位1，表示SYN/ACK报文。最后把报文段发送给客户端，该报文段不包含应用层数据，之后服务端处于SYN_RCVD状态。

![三次握手第三个报文](C:\Users\wangjie\Desktop\study\OkHttp3\img\三次握手第三个报文.webp)

(4) 客户端收到服务端的SYN/ACK报文后，首先在自己的TCP报文段头部的确认位设置为server_isn + 1，同时确认ACK位设置为1，表示是ACK报文段。最后把报文段发送给服务端，这次报文可以携带应用层数据，之后客户端处于ESTABLISHED状态。

(5) 服务端收到客户端的ACK报文段之后，也进入ESTABLISHED状态。

从上面的过程可以发现第三次握手是可以携带数据的，前两次是不可以携带数据的。一旦三次握手完成，双方都处于ESTABLISHED状态，此时连接就建立完成了，客户端和服务端就可以相互发送数据了。

### 2.2.2 为什么是三次握手

三次握手的原因：

(1) 避免重复历史连接的初始化；（2）同步双方的初始序号；（3）避免资源浪费。

#### 2.2.2.1 避免历史连接

三次握手的首要原因是防止旧的重复连接初始化造成混乱。

#### 2.2.2.2 同步双方的初始序号

TCP协议的通信双方，都必须维护一个序号，序号是可靠传输的一个关键因素，它的作用如下：

. 接收方可以丢弃重复的报文段；. 接收方可以根据报文段的序号按顺序接收；. 发送发可以根据ACK报文中的序号识别哪些报文被对方接收。

#### 2.2.2.3 避免资源浪费

如果只有两次握手，当客户端发送的SYN报文在网络中阻塞，客户端没有收到ACK报文，就会重新发送SYN，由于没有第三次握手，服务端不清除客户端是否收到了自己回复的ACK报文，所以服务端每收到一个SYN报文就建立一个连接，出现无效连接造成不必要的资源浪费。

#### 2.2.2.4 小节

TCP建立连接通过三次握手能避免重复历史连接的初始化、同步双方的初始序号、避免资源浪费。序号能保证报文段不重复和有序传输。

不使用二次握手和四次握手的原因：

. 两次握手无法避免历史连接的初始化，造成资源浪费。

. 三次握手已经建立可靠的连接，不需要更多的握手。

## 2.3 TCP连接断开

TCP连接的断开是由四次挥手实现的。

### 2.3.1 四次挥手的过程

客户端和服务端双方都可以主动断开连接，断开后主机的资源得到释放。

![TCP四次挥手](C:\Users\wangjie\Desktop\study\OkHttp3\img\TCP四次挥手.webp)

(1) 客户端打算关闭连接，发送一个FIN报文，之后客户端进入FIN_WAIT_1状态。

(2) 服务端收到报文后，向客户端发送一个ACK报文，接着服务端进入CLOSE_WAIT状态。

(3) 客户端收到服务端的ACK报文之后，进入FIN_WAIT_2状态。

(4) 服务端处理完数据之后，发送一个FIN报文，之后进入LAST_ACK状态。

(5) 客户端收到服务端的FIN报文之后，发送一个ACK报文，之后进入TIME_WAIT状态。

(6) 服务端收到客户端的ACK报文之后，进入CLOSE状态，服务端关闭了连接。

(7) 客户端经过2msl一段时间后，进入CLOSE状态，客户端关闭就了连接。

双方都发送了一个FIN和一个ACK报文，所以通常称为四次挥手。

只有主动关闭连接的一方，才有TIME_WATI状态。

### 2.3.2 为什么挥手需要四次

(1) 关闭连接时，客户端发送FIN报文，表示客户端不再发送数据了，但是还能接收数据。

(2) 服务端收到客户端的FINN报文时，返回一个ACK应答报文，而服务端可能还需要发送或处理数据；等服务端不再发送数据时，才发送FIN报文给客户端表示同意关闭连接。

服务端的ACK和FIN报文需要分开发送，因此需要四次挥手。

### 2.3.3 为什么TIME_WAIT的时间时2MSL？

MSL是Maximum Segment Lifetime，报文最大生存时间，它是报文在网络中最大生存时间，超过这个时间的报文会被丢弃。因为TCP报文是基于IP协议的，而IP头中有一个TTL字段，是IP数据包可以经过的最大路由数，每经过一个处理它的路由器此值就减1，当此值为0则数据包被丢弃，同时发送ICMP报文通知源主机。

MLS应该大于等于TTL消耗到位0的时间，以确保报文自然消亡。

TTL一般是64，Linux将MSL设置为30s，意味着Linux认为u数据报文经过64个路由器的时间不会超过30s，如果超过了，就认为报文已经消失在网络中了。

TIME_WATI等待2MSL，比较合理的解释是：发送方将数据包发送到网络后，数据包被对方接收后又会发送应答的数据包，一来一回需要2倍的时间。被关闭方没有收到最后一个ACK报文后，会重新发送FIN报文，对方收到FIN报文后，会重发ACK报文，这样在2MSL的时间内对方不会及早进入CLOSE状态，保证成功的断开连接。

2MSL的时间是从客户端发送最后一个ACK开始计时的。

# 3 HTTP

## 3.1 HTTP的基本概念

### 3.1.1 HTTP是什么？

​	HTTP是超文本传输协议的简称，HyperText Transfer Protocol。是一个计算机世界里在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

### 3.1.2 HTTP常见的状态码

![五大类HTTP状态码](C:\Users\wangjie\Desktop\study\OkHttp3\img\五大类HTTP状态码.webp)

### 3.1.3 HTTP常见的字段有哪些？

HOST字段

客户端发送请求时用来指定服务器的域名。

![HOST字段](C:\Users\wangjie\Desktop\study\OkHttp3\img\HOST字段.webp)

Content-Length字段

服务器在返回数据时，会有Content-Length字段，表明本次应答的数据长度。

Connection

Connection字段最常用于客户端要求服务器使用HTTP长连接机制，以便其他请求复用。

![connection字段](C:\Users\wangjie\Desktop\study\OkHttp3\img\connection字段.png)

HTTP长连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

![HTTP长连接的通信过程](C:\Users\wangjie\Desktop\study\OkHttp3\img\HTTP长连接的通信过程.webp)

HTTP/1.1版本的默认连接都是长连接，但是为了兼容老版本的HTTP，需要指定Connection首部字段的值为Keep-Alive。

开启了HTTP Keep-Alive机制后，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或者服务端提出断开连接。

Content-Type字段

用户服务器应答时，告诉客户端，本次数据是什么格式。

![content-type字段](C:\Users\wangjie\Desktop\study\OkHttp3\img\content-type字段.webp)



上面的数据表明，发送的是网页，而且编码是UTF-8。

客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。

```k
客户端表明自己可以接受任何格式的数据。
Accept:*/*
```

Content-Encoding

说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。

![content-encoding字段](C:\Users\wangjie\Desktop\study\OkHttp3\img\content-encoding字段.webp)

```k
Content-Encoding:gzip
```

上面表示服务器返回的数据采用了gzip方式压缩，告知客户端需要用此方式解压。

客户端在请求时，使用Accept-Encoding字段说明自己可以接受哪些压缩方法。

```k
Accept-Encoding:gzip, deflate
```

## 3.2 GET和POST

根据RFC规范，GET的语义是从服务器获取指定的资源，这个资源可以是静态的文本、网页、图片或视频等。GET请求的参数一般写在URL中，URL规定只支持ASCII字符。而且浏览器对URL的长度有限制。

POST语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式因资源类型而不同。POST请求携带数据的位置一般写在报文body中，body中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对body大小做限制。

比如，对文章留言，敲了留言后点击提交，浏览器就会执行一次POST请求，把留言文字放进报文body里，然后拼接好POST请求头，通过TCP协议发送给服务器。

![Post请求](C:\Users\wangjie\Desktop\study\OkHttp3\img\Post请求.webp)

### 3.2.1 GET和POST方法都是安全和幂等的吗？

安全和幂等的概念

. 在HTTP协议里，安全指的是请求不会破坏服务器上的资源。

. 幂等指的是多次执行相同的操作，结果都是相同的。

如果从RFC规范定义来看：

. GET方法就是安全且幂等的，因为它是只读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以可以对GET请求的数据做缓存。

. POST因为是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以浏览器一般不会缓存POST请求。

但是实际过程中，开发者不一定会按照RFC规范的定义来实现GET和POST方法。比如：

. 可以用GET方法实现新增或删除数据的请求，这样实现的GET方法自然就不是安全和幂等的。

. 可以用POST方法实现查询数据的请求，这样实现的POST方法就是安全和幂等的。

如果安全是值信息是否会被泄漏的话，虽然POST用body传输数据，而GET用URL传输数据，这样数据会在浏览器地址栏容易看到，但是并不能说POST比GET安全。因为HTTP传输的内容都是明文的，虽然在浏览器地址栏看不到POST提交的body数据，但是只要抓个包就都能看到了。所以要避免传输过程中数据被窃取，就要使用HTTPS协议，这样所有HTTP的数据都会被加密传输。

### 3.2.2 HTTP与HTTPS

#### 3.2.2.1 HTTP与HTTPS有哪些区别？

(1) HTTP的数据是明文传输，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL/TLS安全协议，使得报文能够加密传输。

(2) HTTP连接建立相对简单，TCP三次握手之后便可以进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需要进行SSL/TLS的握手。

(3) 两者的默认端口不一样，HTTP默认端口是80，HTTPS默认端口是443。

(4) HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

#### 3.2.2.2 HTTPS解决了HTTP的哪些问题？

HTTP由于是明文传输，所以安全上存在以下三个风险：

. 窃听风险，比如通信链路上可以获取通信内容。

. 篡改风险，比如强制植入垃圾广告。

. 冒充风险，比如冒充淘宝网站。

![HTTPS与HTTP.webp](C:\Users\wangjie\Desktop\study\OkHttp3\img\HTTPS与HTTP.webp)

HTTPS在HTTP和TCP之间加入了SSL/TLS协议，可以很好的解决上述的风险：

. 信息加密：交互信息无法被窃取。

. 校验机制：无法篡改通信内容。

. 身份证书：解决了服务器身份问题。

HTTPS通过混合加密的方式实现信息的机密性，解决了窃听的风险；通过摘要算法和数字签名实现数据的完整性，解决被篡改的风险；通过数字证书保证了服务器身份的可信，解决了被冒充的风险。

(1) 混合加密

通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。

![混合加密](C:\Users\wangjie\Desktop\study\OkHttp3\img\混合加密.webp)



HTTPS采用的是对称加密和不对称加密结合的混合加密方式：

. 在通信建立前采用不对称加密的方式交换会话密钥。

. 在通信过程中全部采用会话密钥的对称加密方式加密解密明文数据。

采用混合加密方式的原因：

. 对称加密只采用一个密钥，运算速度快，但是无法做到安全的互换密钥。

. 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了会话密钥互换的问题，但运算速度慢。

(2) 摘要算法 + 数字签名

为了保证传输的数据不被篡改，需要对数据计算出一个指纹，然后同数据一同传输给对方。对方收到后，先是对数据同样计算出一个指纹，然后跟发送方的指纹做比较，如果指纹相同，说明数据没有被篡改，否则就可以判断出数据被篡改了。

通过摘要算法（哈希函数）来计算数据的哈希值，也就是数据的指纹，这个哈希值是唯一的，且无法根据哈希值推到出内容。

![摘要算法](C:\Users\wangjie\Desktop\study\OkHttp3\img\摘要算法.webp)

通过哈希算法可以确保数据不会被篡改，但是并不能保证数据+哈希值不会被中间人替换，因为这里缺少对客户端收到的数据是否来源于服务端的证明。

为了避免这种情况，采用非对称加密算法来解决，共有两个密钥：

. 一个是公钥，这个是可以任意分发给客户端的。

. 一个是私钥，这个必须由服务端报关。

这两个密钥可以双向加解密，比如可以用公钥加密数据，然后用私钥解密，也可以用私钥加密数据，公钥解密数据。流程的不同，意味着目的不同。

. 公钥加密，私钥解密。是为了保证数据传输的安全，因为公钥加密的数据，只有持有私钥的一方才能解密。

. 私钥加密，公钥解密。是为了保证数据来源的可靠性，因为私钥是不可泄漏的，如果公钥能解密数据，就能说明数据是来源于持有私钥一方。

一般我们不用非对称加密来加密实际传输的数据，因为非对称加密的计算比较消耗性能。非对称加密的用途主要在于通过私钥加密，公钥解密的方式，确认数据来源的可靠性，通常说的数字签名算法就是用的这种方式，不过私钥加密的不是数据，而是对数据的哈希值进行加密。

![数字签名](C:\Users\wangjie\Desktop\study\OkHttp3\img\数字签名.webp)

私钥是由服务端保管的，客户端拥有公钥。如果客户端收到的数据可以被公钥解密，就说明数据是由服务端萨松的。

(3) 数字证书

如果非对称加密的公钥和私钥是伪造的，且客户端一侧的公钥就是伪造的，那么数字签名就不能保证数据来源的可靠性。数字证书就是解决这个问题的，数字证书由权威的结构（CA 数字证书认证机构）颁发，将服务器的公钥放在证书中，只要证书是可信的，公钥就是可信的。

![数字证书工作流程](C:\Users\wangjie\Desktop\study\OkHttp3\img\数字证书工作流程.webp)

服务器的公钥 + 公钥的数字签名 即为数字证书。

#### 3.2.2.3 HTTPS是如何建立连接的？期间交互了什么？

SSL/TLS协议基本流程：

(1) 客户端向服务器索要数字证书并验证服务器的公钥。

(2) 双发协商产生会话密钥。

(3) 双方采用会话密钥进行加密通信。

前两步是SSL/TLS的建立过程，也就是TLS握手阶段。

TLS的握手阶段涉及四次通信，使用不同的密钥交换算法，TLS握手流程也会不一样，现在常用的密钥交换算法由两种：RSA算法和ECDHE算法。

基于RSA算法的TLS握手过程比较简单，如下是TSL握手过程示意图：

![HTTPS工作流程](C:\Users\wangjie\Desktop\study\OkHttp3\img\HTTPS工作流程.webp)

TLS协议建立的详细流程：

(1) ClientHello

首先客户端向服务器发起加密通信请求，也就是ClientHello。这一步客户端主要向服务器发送以下信息：

. 客户端支持的TLS协议版本，如TLS1.2版本。

. 客户端生成的随机数(Client Random)，用于生成会话密钥的条件。

. 客户端支持的密码套件，如RSA加密算法。

(2) ServerHello

服务器收到客户端请求后，向客户端发送响应，也就是ServerHello。服务器回应的内容如下：

. 确认TLS协议版本。

. 服务器生成的随机数(Server Random)，用于生成会话密钥的条件。

. 确认的密码套件，比如RSA算法。

. 服务器的数字证书。

(3) 客户端回应

客户端收到服务器的回应之后，首先通过浏览器或者操作系统内置的CA公钥，确认服务器数字证书的真实性。如果证书没问题，客户端会从数字证书中取出服务器的公钥，然后使用它来加密报文，向服务器发送如下信息：

. 一个随机数(pre-master key)。该随机数被服务器公钥加密。

. 加密通信算法改变通知，表示随后的信息都将用会话密钥加密通信。

. 客户端握手结束通知。同时把之前所有内容发送的数据做个摘要，用来供服务器校验。

服务器和客户端有了这三个随机数(Client Random、Server Random、pre-master key)，接着就用双方协商的加密算法各自生成本次通信的会话密钥。

(4) 服务器最后回应

服务器收到客户端的第三个随机数(pre-master key)之后，通过协商的加密算法，计算出本次通信的会话密钥。然后向客户端发送最后的信息：

. 加密通信算法改变的通知，表示随后的信息都将用会话密钥加密。

. 服务器握手结束通知，同时把之前所有内容发生的数据做个摘要，用来供客户端校验。

自此，整个TLS的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用会话密钥加密内容。 
