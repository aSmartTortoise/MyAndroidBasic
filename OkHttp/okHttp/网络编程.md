网络通信

参考文章

[一文搞懂TCP与UPD的区别](https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html)

[图解网络](https://www.xiaolincoding.com/network/)

[关于TCP三次握手和四次挥手，满分回答在此](https://segmentfault.com/a/1190000039165592)

[SSL/TLS协议详解](https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/)

# 1 开放式互联网模型

开放式互联网模型（OpenSystermInterconnection Model），简称OSI模型，是一种互联网概念化模型，由国际标准化组织（InternationalOrganization forStandardization），简称ISO，提出。OSI模型将互联网分为七层分别为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

![OSI模型与tcp/ip模型](C:\Users\wangjie\Desktop\study\网络\img\OSI_tcp_ip模型.png)

# 1 TCP/IP网络模型

计算机或网络设备间要相互通信，双方就必须基于相同的协议。比如，如何探测通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要确定。不同的硬件、操作系统之间的通信都需要一种规则，这种规则称为协议。

TCP/IP网络模型是一系列网络协议的总称。这个模型可以分为四层，分别为链路层、网络层、传输层、应用层。

![tcpip网络模型.webp](C:\Users\wangjie\Desktop\study\网络\img\tcpip网络模型.webp)

## 1.1 应用层

最上层的，电脑手机使用的应用软件都是在应用层实现。当两个设备的应用需要通信的时候，应用把数据传给传输层。应用层不用关心数据是如何传输的。而且应用层对应操作系统的用户态，传输层及以下对应操作系统的内核态。

## 1.2 传输层

应用层的数据会传给传输层，传输层为应用层提供网络支持。

在传输层有两个重要的通信协议，分别是TCP和UDP。

### 1.2.1 UDP

UDP传输层协议全称是用户数据报协议(User Datagram Protocol)。它有以下特点：

#### 1.2.1.1 面向无连接

首先在发送数据前不需要建立连接。UDP不止支持一对一的传输方式，同样支持一对多、多对多、多对一的方式，也就是说UDP提供了单播、多播、广播的功能。

#### 1.2.1.2 UDP是面向报文的

不会对数据报文进行拆分和拼接操作，具体来说；

+ 在发送端，应用层将数据传递给传输层，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了。

+ 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作。

因此应用层必须选择合适大小的报文。

#### 1.2.1.3 不可靠性

由于发送数据前不建立连接，这种情况就是不可靠的。传输层收到什么数据就传递什么数据，不备份数据，不关心对方是否接收到数据。以恒定的速度发送数据，即使网络环境不好，也不会调整发送速度，会导致丢包。

#### 1.2.1.4 头部开销小，传输数据报文高效

UDP头部只有8个字节，开销小，相比TCP的至少二十字节少得多，传输数据报文高效。

![udp头.webp](C:\Users\wangjie\Desktop\study\网络\img\udp头.webp)

### 1.2.2 TCP

TCP协议全称是传输控制协议(Transmission Control Protocol)。是一种面向连接、基于字节流、可靠的传输层协议。

#### 1.2.2.1 面向连接

一定是一对一的，不能向UDP协议可以一对多，多对多的通信。

#### 1.2.2.2 基于字节流

数据通过TCP协议传输时，数据可能被操作系统拆分成多个TCP段。TCP报文段是有序的，当前一个报文段没有收到的时候，后面的报文段，也不能传给应用层处理，同时重复的TCP报文段会自动丢弃。

#### 1.2.2.3 可靠的

基于TCP协议的发送方会备份TCP报文段，通信过程中如果有报文顺坏或丢失，会重新发送这一个报文段，这样可以保证一个报文段能够到达接受方。





应用需要传输的数据可能非常大，如果直接传递就不好控制，当传递的数据包大小超过MSS（最大数据报文段长度），就要将数据包分块。这个每个分块叫做TCP段(Segment)。

当设备作为接收方时，传输层将数据包传递给应用层，但是一台设备上可能有很多应用在接收或传递数据，因此需要将应用区分开来，端口可以区分应用。由于传输层的数据包中的TCP头会携带端口，因此接收方可以识别出该数据包发送给哪个应用。

## 1.3 网络层

网络层常用的是IP协议（Internet Protocol）。传输层将数据传递给网络层，IP协议会在报文的基础上加上IP头组成IP报文，如果IP报文大小超过MTU（Maximum Transmission Unit，以太网中一般为1500字节），协议就会将报文再次分块。每个分块叫packet。

![应用层_传输层_网络层等报文结构](C:\Users\wangjie\Desktop\study\网络\img\应用层_传输层_网络层等报文结构.webp)

用IP地址给设备编号，对于IPv4协议，IP地址共有32位，分成了四段（192.168.100.1），每段是8位。IP地址有两重意义：

+ 网络号，标识该IP地址属于哪个子网。

+ 主机号，标识同一个子网下的主机。

IP地址结合**子网掩码**可以计算出网络号和主机号。

IP地址和子网掩码进行位与运算得到网络号，IP地址和取反后的子网掩码进行位与运算得到主机号。根据IP地址和子网掩码计算得到网络号和主机号的过程叫做寻址。

实际场景中两台设备之间有很多网关、路由器、交换机等众多网络设备，形成很多条网络路径，当报文到达某个网络节点后，接着由路由算法决定走哪一条网络路径。

IP协议有寻址和路由两个作用，寻址就是获取目标设备所在的网络号和主机号，路由就是获取报文到达目标设备的网络路径。

## 1.4 链路层

网络层将IP数据包传递给链路层，链路层会在IP头的基础上添加MAC头，并封装成数据帧（Data Frame）发送到网络。MAC包含了接收方和发送方的MAC地址信息，MAC地址标识设备。

链路层（网络接口层）为网络层提供**链路级别**传输的服务，负责在以太网、WiFi这样的底层网络上发送原始数据包。

## 1.5 总结

链路层传输的是帧(Frame)、网络层传输的是包(packet)、传输层传输的是段(Segment)、应用层传输的是消息或报文（message）。但这些名称并没有本质的区别，可以统称为数据包。

# 2 TCP

## 2.1 TCP头

TCP头部有多个字段，这些字段占用的大小不同。

![TCP头](C:\Users\wangjie\Desktop\study\网络\img\tcp头.webp)

源端口号和目标端口号是不可少的，用来标识接收和发送方的应用。

**序列号**：表示该数据包数据第一个字节的编号；在建立连接时发送方主机生成的一个随机数作为其初始值（Init Sequence Number ISN），每发送一次数据，序列号就累加一次该数据字节数的大小。用来解决数据包乱序问题。

**确认号**：期望收到的数据包的序列号，若确认号为N，则序号N-1之前的数据都收到了，需要和**ACK位**配合使用。用来解决丢包问题。

**首部长度（数据偏移）**：指的是TCP数据包数据起始处距离数据包起始处有多远。这个字段实际指的是TCP数据包的首部长度。

**保留位**：一共6个，保留位今后使用。

**控制位**

控制位有6个，比较重要，每个控制位各占一位。用来说明TCP数据包性质的。

+ **紧急位URG**：当URG=1时，表明该数据包中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队等待。该控制位需要配合**紧急指针**使用（紧急指针指出本数据包紧急数据的字节数）。

+ **确认位ACK**：仅当ACK=1时，确认号字段才有效，当ACK=0时确认号无效。TCP规定，在连接建立后所有传送的数据包的ACK位必须为1。ACK的全称是Acknowledgment。

+ **推送位PSH**：当两个应用通信时，有时一端的应用希望在键入一个命令后立即就能得到对方的响应。在这种情况下，TCP就可以使用推送（PUSH）操作。这时，发送方TCP把PSH设置为1，并发送一个数据包。接收方TCP收到PSH=1的报文段，就尽快响应，不用等到整个缓存都填满后再响应。

+ **复位位RST**：当RST=1时，表明TCP连接中出现了严重错误（比如主机崩溃或其他原因），必须断开连接，然后再重新建立连接。

+ **同步位SYN**：SYN=1，表示这是一个请求连接或接受连接的数据包。当 SYN = 1，ACK = 0 时，表明这是一个连接请求的数据包。对方若同意建立连接，则应在响应的数据包中使 SYN = 1，ACK = 1。

+ **终止位FIN**：当FIN=1时，表明不会再有数据发送。当希望断开连接结束通信时，通信双方可以相互交换FIN位为1的TCP段。

## 2.2 为什么需要TCP协议？TCP工作在哪一层？

`IP`协议是不可靠的，它不保证数据包的交付、不保证数据包按序交付、也不保证数据的完整性。`TCP`协议是一个工作在传输层的可靠的协议，它能保证接收端接受到的数据是完整的、有序的、无重复的。

## 2.3 如何唯一确定一个TCP连接

TCP四元组可以唯一确定一个TCP连接，四元组包括：源地址、源端口、目标地址、目标端口。

源地址和目标地址是32位，在IP头中，是用来确定通信设备的主机。源端口、目标端口是16位，在TCP头中，用来确定通信应用的进程。

## 2.4 TCP连接建立

### 2.4.1 TCP三次握手过程

TCP是面向连接的协议，使用TCP前需要建立连接，而建立连接是通过三次握手实现的。每一次握手都需要发送TCP段，并设置自身状态，对方在接受TCP段之后也相应设置自身的状态或发送相关TCP段。

![TCP三次握手](C:\Users\wangjie\Desktop\study\网络\img\TCP三次握手.webp)

1. 一开始，客户端和服务端都处于`CLOSE`状态。服务端主动监听某个端口，处于`LISTEN`状态。

![三次握手第一个报文](C:\Users\wangjie\Desktop\study\网络\img\三次握手第一个报文.webp)

2. 客户端随机初始化序列号(client_isn)，将序号置于TCP头的序列号字段中，同时将SYN位设置为1，表示SYN段。接着把第一个SYN段发送给服务器，表示向服务器发起请求连接，该报文段不包含应用层数据，之后客户端处于`SYN_SENT`状态。

![三次握手第二个报文](C:\Users\wangjie\Desktop\study\网络\img\三次握手第二个报文.webp)

3. 服务器收到客户端的SYN段后，也随机初始化序列号，并将该序列号置于TCP头部的序列号字段中，将确认号设置为`client_isn + 1`，接着将SYN位和ACK位都设置位1，表示SYN/ACK段。最后把数据段发送给客户端，该TCP段不包含应用层数据，之后服务端处于`SYN_RCVD`状态。



![三次握手第三个报文](C:\Users\wangjie\Desktop\study\网络\img\三次握手第三个报文.webp)

4. 客户端收到服务器的SYN/ACK段后，在自己的TCP段头部的确认位设置为server_isn + 1，ACK位设置为1，表示是ACK段。最后把TCP段发送给服务器，这次TCP段可以携带应用层数据，之后客户端处于`ESTABLISHED`状态。

5. 服务器收到客户端的ACK段之后，也进入`ESTABLISHED`状态。

从上面的过程可以发现第三次握手是可以携带数据的，前两次是不可以携带数据的。一旦三次握手完成，双方都处于`ESTABLISHED`状态，连接就建立完成了，客户端和服务器就可以相互发送数据了。

### 2.4.2 为什么是三次握手

三次握手的原因：

+ 避免历史连接重复初始化照成的混乱；
+ 交换通信双方的初始序列号；
+ 避免资源浪费。

#### 2.4.2.1 避免历史连接的重复初始化

三次握手的首要原因是防止旧的重复连接初始化造成混乱。

#### 2.4.2.2 同步双方的初始序号

TCP协议的通信双方，都必须维护一个序列号，序列号是可靠传输的一个关键因素，它的作用如下：

+ 接收方可以丢弃重复的报文段；
+ 接收方可以根据报文段的序号按顺序接收；
+ 发送发可以根据ACK报文中的序号识别哪些报文被对方接收。

#### 2.4.2.3 避免资源浪费

如果只有两次握手，当客户端发送的SYN报文在网络中阻塞，客户端没有收到ACK报文，就会发送新的SYN，由于没有第三次握手，服务器不清除客户端是否收到了自己的ACK报文，如果服务器每收到一个SYN报文就建立一个连接，就会出现无效连接造成不必要的资源浪费。

#### 2.4.2.4 小节

TCP建立连接通过三次握手能避免重复历史连接的初始化、同步双方的初始序号、避免资源浪费。序号能保证报文段不重复和有序传输。

不使用二次握手和四次握手的原因：

+ 两次握手无法避免历史连接的初始化，造成资源浪费。

+ 三次握手可以建立可靠的连接，不需要更多的握手。

## 2.5 TCP连接的关闭

TCP连接的关闭是通过四次挥手实现的。

### 2.5.1 四次挥手的过程

客户端和服务器双方都可以主动关闭连接，关闭后主机的资源得到释放。

![TCP四次挥手](C:\Users\wangjie\Desktop\study\网络\img\TCP四次挥手.webp)

1. 客户端打算关闭连接，发送一个`FIN`数据段，截止进入FIN_WAIT_1状态。
2. 服务器收到`FIN`段后，向客户端发送一个`ACK`数据段，接着进入CLOSED_WAIT状态。
3. 客户端收到服务器的`ACK`数据段之后，进入FIN_WAIT_2状态。
4. 服务端处理完数据之后，发送一个`FIN`数据段，之后进入`LAST_ACK`状态。
5. 客户端收到服务器的`FIN`数据段之后，发送一个`ACK`数据段，之后进入`TIME_WAIT`状态。
6. 服务器收到客户端的`ACK`报文之后，进入CLOSE状态，服务端关闭了连接。
7. 客户端经过2MSL的时间后，进入CLOSE状态，客户端关闭就了连接。

双方都发送了一个FIN和一个ACK报文，所以通常称为四次挥手。

主动关闭连接的一方，才有TIME_WATI状态。

### 2.5.2 为什么挥手需要四次

+ 关闭连接时，客户端发送FIN数据段，表示客户端不再发送数据了，但是还能接收数据。

+ 服务器收到客户端的FIN数据段时，返回一个ACK数据段，而服务器可能还需要发送或处理数据；等服务端不再发送数据时，才发送FIN数据段给客户端表示同意关闭连接。

服务端的ACK和FIN报文需要分开发送，因此需要四次挥手。

### 2.5.3 为什么TIME_WAIT的时间是2MSL？

`MSL`是Maximum Segment Lifetime，数据段最大生存时间，它是数据段在网络中最大生存时间，超过这个时间段的数据段会被丢弃。因为TCP数据段是基于IP协议的，而IP头中有一个TTL字段，是IP数据包可以经过的最大路由数，每经过一个处理它的路由器此值就减1，当此值为0则数据包被丢弃，同时发送ICMP报文通知源主机。

MLS应该大于等于TTL消耗到位0的时间，以确保数据包自然消亡。

TTL一般是64，Linux将MSL设置为30s，意味着Linux认为数据包经过64个路由器的时间不会超过30s，如果超过了，就认为数据包已经消失在网络中了。

TIME_WATI等待2MSL，比较合理的解释是：发送方将数据包发送到网络后，数据包被对方接收后又会发送应答的数据包，一来一回需要2倍的时间。被关闭方没有收到最后一个ACK数据段后，会触发超时重新发送FIN数据段，对方收到FIN数据段后，会重发ACK数据段，这样在2MSL的时间内对方不会及早进入CLOSE状态，保证成功的断开连接。

2MSL的时间是从主动关闭连接的一方发送最后一个ACK数据段开始计时的。

# 3 HTTP

## 3.1 HTTP的基本概念

### 3.1.1 HTTP是什么？

​	`HTTP`是超文本传输协议的简称，HyperText Transfer Protocol。是一个计算机世界里在两点之间传输文字、图片、音频、视频、压缩包等超文本数据的约定和规范。

### 3.1.2 HTTP常见的状态码

![五大类HTTP状态码](C:\Users\wangjie\Desktop\study\网络\img\五大类HTTP状态码.webp)

### 3.1.3 HTTP常见的字段有哪些？

HOST字段

客户端发送请求时用来指定服务器的域名。

![HOST字段](C:\Users\wangjie\Desktop\study\网络\img\HOST字段.webp)

Content-Length字段

服务器在返回数据时，会有Content-Length字段，表明本次应答的数据长度。

Connection

Connection字段最常用于客户端要求服务器使用HTTP长连接机制，以便其他请求复用。

![connection字段](C:\Users\wangjie\Desktop\study\网络\img\connection字段.png)

HTTP长连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

![HTTP长连接的通信过程](C:\Users\wangjie\Desktop\study\网络\img\HTTP长连接的通信过程.webp)

HTTP/1.1版本的默认连接都是长连接，但是为了兼容老版本的HTTP，需要指定Connection首部字段的值为Keep-Alive。

开启了HTTP Keep-Alive机制后，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或者服务端提出断开连接。

Content-Type字段

用户服务器应答时，告诉客户端，本次数据是什么格式。

![content-type字段](C:\Users\wangjie\Desktop\study\网络\img\content-type字段.webp)



上面的数据表明，发送的是网页，而且编码是UTF-8。

客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。

```k
客户端表明自己可以接受任何格式的数据。
Accept:*/*
```

Content-Encoding

说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。

![content-encoding字段](C:\Users\wangjie\Desktop\study\网络\img\content-encoding字段.webp)

```k
Content-Encoding:gzip
```

上面表示服务器返回的数据采用了gzip方式压缩，告知客户端需要用此方式解压。

客户端在请求时，使用Accept-Encoding字段说明自己可以接受哪些压缩方法。

```k
Accept-Encoding:gzip, deflate
```

## 3.2 GET和POST

根据RFC（Requests for Comments   请求意见稿）规范，**GET的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、网页、图片或视频等。GET请求的参数一般写在URL中，URL规定只支持ASCII字符。而且浏览器对URL的长度有限制。

**POST语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式因资源类型而不同。POST请求携带数据的位置一般写在报文body中，body中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对body大小做限制。

比如，对文章留言，敲了留言后点击提交，浏览器就会执行一次POST请求，把留言文字放进报文body里，然后拼接好POST请求头，通过TCP协议发送给服务器。

![Post请求](C:\Users\wangjie\Desktop\study\网络\img\Post请求.webp)

### 3.2.1 GET和POST方法都是安全和幂等的吗？

安全和幂等的概念

+ 在HTTP协议里，安全指的是请求不会破坏服务器上的资源。

+ 幂等指的是多次执行相同的操作，结果都是相同的。

如果从RFC规范定义来看：

+ GET方法就是安全且幂等的，因为它是只读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以可以对GET请求的数据做缓存。

+ POST因为是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以浏览器一般不会缓存POST请求。

但是实际项目中，开发者不一定会按照RFC规范的定义来实现GET和POST方法。比如：

+ 可以用GET方法实现新增或删除数据的请求，这样实现的GET方法自然就不是安全和幂等的。

+ 可以用POST方法实现查询数据的请求，这样实现的POST方法就是安全和幂等的。

如果安全是值信息是否会被泄漏的话，虽然POST用body传输数据，而GET用URL传输数据，这样数据会在浏览器地址栏容易看到，但是并不能说POST比GET安全。因为HTTP传输的内容都是明文的，虽然在浏览器地址栏看不到POST提交的body数据，但是只要抓个包就都能看到了。所以要避免传输过程中数据被窃取，就要使用HTTPS协议，这样所有HTTP的数据都会被加密传输。

## 3.3 HTTP缓存技术

HTTP缓存有两种实现方式：强制缓存和协商缓存。

### 3.3.1 强制缓存

强制缓存指的是客户端判断如果缓存没有过期，则直接使用客户端的磁盘缓存，决定是否使用缓存的主动性在客户端。

强制缓存是通过响应头的`Cache-Control`或`Expires`键值对实现的，它们表示返回给客户端的资源的有效期。

+ `cache-control`，是一个相对时间。
+ `Expires`是一个绝对时间。

如果HTTP响应头同时有`Cache-Control`和`Expires`键值对的话，`Cache-Control`的优先级高于`Expires`。

`Cache-Control`选项更多一些，设置更加精细，所以建议使用`Cache-Control`来实现强制缓存。具体的实现流程如下：

+ 当客户端第一次请求服务器资源时，服务器会在返回这个资源的Response头部加上`Cache-Control`头，比如指定`max-age`等。
+ 客户端再次请求服务器资源时，会先通过请求资源的时间与缓存响应的`Cache-Control`Header设置的有效期时间和可允许使用的时间来计算资源是否过期，如果没有过期，则使用缓存，否则重新发起请求。
+ 服务器再次收到请求后，会再次更新`Response`的`Cache-Control`Header。

### 3.3.2 协商缓存

服务器返回的资源Response的状态码是304，表示客户端可以使用本地磁盘缓存，这种服务器告诉客户端是否可以使用缓存的方式被称为**协商缓存**。

![HTTP网络协商缓存.webp](C:\Users\wangjie\Desktop\study\网络\img\HTTP网络协商缓存.webp)

上图就是个协商缓存的过程。

协商缓存可以基于两种头部实现：

1. 请求头中的`If-Modified-Since`键值对和响应头中的`Last-Modified`键值对实现。
2. 请求头中的`If-None-Match`键值对和响应头中的`ETag`键值对。

+ 响应头中的`ETag`键值对是资源唯一性的标识。
+ 当缓存的资源过期时，且缓存响应的头部有`ETag`键值对，客户端发起请求时，头部设置`If-None-Match`键值对，值为`ETag`的值，服务器收到请求后会进行对比，如果资源没有改动，则返回304的响应，如果资源改动了则返回200的响应。

第一种实现方式是基于时间，第二种是基于资源的唯一标识，后者更准确地判断资源是否发生了改动，避免由于时间篡改导致不可靠。

如果客户端请求的头部同时设置了`If-None-Match`和`If-Modified-Since`键值对，这时`ETag`的优先级高。服务器会先判断`If-None-Match`如果没有变化，再判断`If-Modified-Since`。



缓存策略是先判断是否满足强制缓存，如果不满足再判断协商缓存。

## 3.4 HTTP与HTTPS

### 3.4.1 HTTP与HTTPS有哪些区别？

+ HTTP的数据是明文传输，存在安全问题。HTTPS在TCP和HTTP之间加入了SSL/TLS（Secure Sockets Layer，安全套接字层，Transport Layer Security，传输层安全）安全协议，报文经过加密后传输。

+ HTTP连接建立相对简单，TCP三次握手之后便可以进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需要进行SSL/TLS的握手。

+ 两者的默认端口不一样，HTTP默认端口是80，HTTPS默认端口是443。

+ HTTPS协议需要向CA（数字证书认证机构）申请数字证书，来确认服务器的身份。

### 3.4.2 HTTPS解决了HTTP的哪些问题？

HTTP在安全上存在以下三个问题：

+ 窃听风险，比如通信链路上可以窃取传输的数据。

+ 篡改风险，比如强制植入垃圾广告。

+ 冒充风险，比如冒充淘宝网站。

![HTTPS与HTTP.webp](C:\Users\wangjie\Desktop\study\网络\img\HTTPS与HTTP.webp)

HTTPS在HTTP和TCP之间加入了SSL/TLS安全协议，可以很好的解决上述的安全问题：

+ 信息加密：交互信息无法被窃取。

+ 校验机制：无法篡改通信内容。

+ 身份证书：解决了服务器身份问题。

HTTPS通过**混合加密**的方式实现信息的机密性，解决了窃听问题；通过**摘要算法**和**数字签名**实现信息的完整性，解决被篡改的问题；通过**数字证书**确认了服务器身份，解决了被冒充的问题。

**混合加密**

通过混合加密的方式实现信息的机密性，解决了窃听的问题。

![混合加密](C:\Users\wangjie\Desktop\study\网络\img\混合加密.webp)



HTTPS采用的是**对称加密**和**不对称加密**结合的混合加密方式：

+ 在通信建立前采用**不对称加密**的方式交换会话密钥。

+ 在通信过程中全部采用**会话密钥**的对称加密方式加密明文数据。

采用**混合加密**方式的原因：

+ 对称加密只使用一个密钥，运算速度快，但是无法做到安全的互换密钥。

+ 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了会话密钥互换的安全问题，但运算速度慢。

**摘要算法 + 数字签名**

为了保证传输的数据不被篡改，需要对数据计算出一个指纹，然后同数据一同传输给对方。对方收到后，先是对数据同样计算出一个指纹，然后跟发送方的指纹做比较，如果指纹相同，说明数据没有被篡改，否则就可以判断出数据被篡改了。

通过**摘要算法（哈希函数）**来计算数据的哈希值，也就是数据的指纹，这个哈希值是唯一的，且无法根据哈希值推到出内容。

![摘要算法](C:\Users\wangjie\Desktop\study\网络\img\摘要算法.webp)

> 通过**哈希算法**可以确保数据不会被篡改，但是并不能保证数据+哈希值不会被中间人替换，因为这里缺少对客户端收到的数据是否来源于服务端的证明。

为了避免这种情况，采用非对称加密算法来解决，共有两个密钥：

+ 一个是公钥，这个是可以任意分发给客户端的。

+ 一个是私钥，这个必须由服务器保管，不可泄漏。

这两个密钥可以双向加解密，比如可以用公钥加密数据，然后用私钥解密，也可以用私钥加密数据，公钥解密数据。流程的不同，意味着目的不同。

+ 公钥加密，私钥解密。是为了保证数据传输的安全，因为公钥加密的数据，只有持有私钥的一方才能解密。

+ 私钥加密，公钥解密。是为了保证数据来源的可靠性，因为私钥是不可泄漏的，如果公钥能解密数据，就能说明数据是来源于持有私钥一方。

一般我们不用非对称加密来加密实际传输的数据，因为非对称加密的计算比较消耗性能。非对称加密的用途主要在于通过私钥加密，公钥解密的方式，确认数据来源的可靠性，通常说的**数字签名算法**就是用的这种方式，不过私钥加密的不是数据，而是对数据的哈希值进行加密。

![数字签名](C:\Users\wangjie\Desktop\study\网络\img\数字签名.webp)

私钥是由服务器保管的，客户端拥有公钥。如果客户端收到的数据中的数字签名可以被公钥解密，就说明数据是由服务端发送的。

**数字证书**

如果非对称加密的公钥和私钥是伪造的，且客户端一侧的公钥就是伪造的，那么数字签名就不能保证数据来源的可靠性。数字证书就是解决这个问题的，数字证书由权威的结构（CA 数字证书认证机构）颁发，将服务器的公钥放在证书中，只要证书是可信的，公钥就是可信的。

![数字证书工作流程](C:\Users\wangjie\Desktop\study\网络\img\数字证书工作流程.webp)

服务器的公钥 + 公钥的数字签名 即为数字证书。数字证书确保了服务器身份，解决了冒充服务器的问题。

### 3.4.3 HTTPS是如何建立连接的？期间交互了什么？

SSL/TLS协议基本流程：

1. 客户端向服务器索要并验证公钥。
2.  双发协商产生会话密钥。
3. 双方采用会话密钥进行加密通信。

前两步是SSL/TLS的建立过程，也就是TLS握手阶段。

TLS的握手阶段涉及四次通信，使用不同的密钥交换算法，TLS握手流程也会不一样，现在常用的密钥交换算法有两种：RSA算法和ECDHE算法。

基于RSA算法的TLS握手过程比较简单，如下是TSL握手过程示意图：

![HTTPS工作流程](C:\Users\wangjie\Desktop\study\网络\img\HTTPS工作流程.webp)

TLS握手的详细流程：

1. ClientHello

首先客户端向服务器发起加密通信请求，也就是`Client Hello`。这一步客户端主要向服务器发送以下信息：

+ 客户端支持的TLS协议版本，如TLS1.2版本。

+ 生成的随机数(`Client Random`)，用于生成会话密钥。

+ 客户端支持的密码套件列表，如RSA加密算法。



2. ServerHello

服务器收到客户端请求后，向客户端发送响应，也就是`Server Hello`。服务器回应的内容如下：

+ 确认TLS协议版本。

+ 生成的随机数(`Server Random`)，用于生成会话密钥。

+ 确认的密码套件列表，比如RSA算法。

+ 服务器的数字证书。



3. 客户端回应

客户端收到服务器的回应之后，首先通过浏览器或者操作系统内置的CA公钥，确认服务器数字证书的真实性。如果证书没问题，客户端会从数字证书中取出服务器的公钥，然后使用它来加密报文，向服务器发送如下信息：

+ 一个随机数(`pre-master key`)，该随机数被服务器公钥加密。

+ 加密通信算法改变通知，表示随后的信息都将用会话密钥加密通信。

+ 客户端握手结束通知，同时把之前所有发送的数据做个摘要，用来供服务器校验。

服务器和客户端有了这三个随机数(Client Random、Server Random、pre-master key)，接着就用双方协商的加密算法各自生成本次通信的会话密钥。



4. 服务器最后回应

服务器收到客户端的第三个随机数(`pre-master key`)之后，通过协商的加密算法，计算出本次通信的会话密钥。然后向客户端发送最后的信息：

+ 加密通信算法改变的通知，表示随后的信息都将用会话密钥加密。

+ 服务器握手结束通知，同时把之前所有内容发生的数据做个摘要，用来供客户端校验。

至此，整个TLS的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用会话密钥加密内容。 
